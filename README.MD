# IRIS HIBERNATE KEY TEST

This is a simple example of natural key using Hibernate and Intersystems Iris datase to show some problems I am facing.

## Problem
Consider a Natural Key with an Identity (Serial) field.

I cannot seem to acquire the generated value after persisting my entity. That is, the returned entity by Spring Data's "save" does not have the generated value.

The value is generated by the database, and I can query it after `repository.save(entity)`. 

## Set up
Manually create a table within Iris
```sql
CREATE TABLE test (
	test_id serial NOT NULL,
	uuid varchar(36) NOT NULL,
	name varchar(100) NULL,
	test_date date NULL,
	CONSTRAINT pk_test PRIMARY KEY (test_id, uuid)
);
```

Verify the connection properties (application.yml)
```yaml
  datasource:
    url: "jdbc:IRIS://172.17.0.2:1972/USER"
    driver-class-name: "com.intersystems.jdbc.IRISDriver"
    hikari:
      username: "_SYSTEM"
      password: "SYS"
```

Build the project
```shell
./gradlew build
```

And run it
```shell
./gradlew bootrun
```

## EmbeddedId (branch "EmbeddedId")

### Mapping
```java
@Entity
@Table(name = "test")
public class Test implements Serializable {

    @EmbeddedId
    private TestPK pk;

    @Column(name = "name")
    private String name;

    @Column(name = "test_date")
    @JsonSerialize(using = LocalDateSerializer.class)
    private LocalDate date;
    
    //...
}
```
```java
@Embeddable
public class TestPK implements Serializable {

    @Column(name = "test_id")
    private Long id;

    @Column(name = "uuid")
    @Type(type = "org.hibernate.type.UUIDCharType")
    private UUID uuid;

    //...
}
```

I understand that Hibernate will try to insert "test_id" as `null`, but Iris accepts it and generates the value nonetheless.

### Testing
```shell
curl -s -X POST http://localhost:8080/test/ -d "name=Jonny" | jq
```
```json
{
  "pk": {
    "id": null,
    "uuid": "0a3c6c5b-c6e5-45f2-94fd-5d5d09c6b45e"
  },
  "name": "Jonny",
  "date": "2021-02-11"
}
```
The generated ID wasn't returned as expected... But I cat obtain it by querying
```shell
curl -s -X GET http://localhost:8080/test/ | jq
```
```json
[
  {
    "pk": {
      "id": 1,
      "uuid": "0a3c6c5b-c6e5-45f2-94fd-5d5d09c6b45e"
    },
    "name": "Jonny",
    "date": "2021-02-11"
  }
]
```

## SQLInsert (branch "SQLInsert")
### Mapping
```java
@Entity
@Table(name = "test")
@SQLInsert(sql = "insert into test (test_date, name, uuid) values (?, ?, ?)")
public class Test implements Serializable {

    @EmbeddedId
    private TestPK pk;

    @Column(name = "name")
    private String name;

    @Column(name = "test_date")
    @JsonSerialize(using = LocalDateSerializer.class)
    private LocalDate date;

    //...
}
```
```java
@Embeddable
public class TestPK implements Serializable {

    @Column(name = "test_id")
    private Long id;

    @Column(name = "uuid")
    @Type(type = "org.hibernate.type.UUIDCharType")
    private UUID uuid;

    //...
}
```

### Testing
```shell
curl -s -X POST http://localhost:8080/test/ -d "name=Jackson" | jq
```
```json
{
  "timestamp": "2021-02-11T13:39:20.929+00:00",
  "status": 500,
  "error": "Internal Server Error",
  "message": "",
  "path": "/test/"
}
```
```log
...
Hibernate: select test0_.test_id as test_id1_0_0_, test0_.uuid as uuid2_0_0_, test0_.test_date as test_dat3_0_0_, test0_.name as name4_0_0_ from test test0_ where test0_.test_id=? and test0_.uuid=?
Hibernate: insert into test (test_date, name, uuid) values (?, ?, ?)
2021-02-11 11:39:20.902  WARN 76157 --- [nio-8080-exec-1] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 463, SQLState: S1002
2021-02-11 11:39:20.902 ERROR 76157 --- [nio-8080-exec-1] o.h.engine.jdbc.spi.SqlExceptionHelper   : Invalid parameter number: 4
2021-02-11 11:39:20.920 ERROR 76157 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.orm.jpa.JpaSystemException: could not insert: [com.jesjobom.persistence.model.Test]; nested exception is org.hibernate.exception.GenericJDBCException: could not insert: [com.jesjobom.persistence.model.Test]] with root cause

java.sql.SQLException: Invalid parameter number: 4
        at com.intersystems.jdbc.ParameterCollection.getUserParameter(ParameterCollection.java:154) ~[intersystems-jdbc-3.2.0.jar:3.2.0]
        at com.intersystems.jdbc.IRISPreparedStatement.setGeneric(IRISPreparedStatement.java:667) ~[intersystems-jdbc-3.2.0.jar:3.2.0]
        at com.intersystems.jdbc.IRISPreparedStatement.setGeneric(IRISPreparedStatement.java:647) ~[intersystems-jdbc-3.2.0.jar:3.2.0]
        at com.intersystems.jdbc.IRISPreparedStatement.setString(IRISPreparedStatement.java:330) ~[intersystems-jdbc-3.2.0.jar:3.2.0]
        at com.zaxxer.hikari.pool.HikariProxyPreparedStatement.setString(HikariProxyPreparedStatement.java) ~[HikariCP-3.4.5.jar:na]
        at org.hibernate.type.descriptor.sql.VarcharTypeDescriptor$1.doBind(VarcharTypeDescriptor.java:46) ~[hibernate-core-5.4.27.Final.jar:5.4.27.Final]
...
```
Somewhere inside the driver it tries to get the 4th parameter, ignoring my custom Insert SQL with 3 parameters.

## IdClass (branch "IdClass")

### Mapping
```java
@Entity
@Table(name = "test")
@IdClass(TestPK.class)
public class Test implements Serializable {

    @Id
    @Column(name = "test_id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Id
    @Column(name = "uuid")
    @Type(type = "org.hibernate.type.UUIDCharType")
    private UUID uuid;

    @Column(name = "name")
    private String name;

    @Column(name = "test_date")
    @JsonSerialize(using = LocalDateSerializer.class)
    private LocalDate date;

    //...
}
```
```java
public class TestPK implements Serializable {

    private Long id;

    private UUID uuid;

    //...
}
```

### Testing
```shell
curl -s -X POST http://localhost:8080/test/ -d "name=James" | jq
```
```json
{
  "timestamp": "2021-02-11T13:49:12.085+00:00",
  "status": 500,
  "error": "Internal Server Error",
  "message": "",
  "path": "/test/"
}
```
```log
...
Hibernate: select test0_.test_id as test_id1_0_0_, test0_.uuid as uuid2_0_0_, test0_.test_date as test_dat3_0_0_, test0_.name as name4_0_0_ from test test0_ where test0_.test_id=? and test0_.uuid=?
2021-02-11 11:52:59.374 ERROR 78839 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.orm.jpa.JpaSystemException: Could not set field value [POST_INSERT_INDICATOR] value by reflection : [class com.jesjobom.persistence.model.TestPK.id] setter of com.jesjobom.persistence.model.TestPK.id; nested exception is org.hibernate.PropertyAccessException: Could not set field value [POST_INSERT_INDICATOR] value by reflection : [class com.jesjobom.persistence.model.TestPK.id] setter of com.jesjobom.persistence.model.TestPK.id] with root cause

java.lang.IllegalArgumentException: Can not set java.lang.Long field com.jesjobom.persistence.model.TestPK.id to org.hibernate.id.IdentifierGeneratorHelper$2
        at java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException(UnsafeFieldAccessorImpl.java:167) ~[na:na]
        at java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException(UnsafeFieldAccessorImpl.java:171) ~[na:na]
        at java.base/jdk.internal.reflect.UnsafeObjectFieldAccessorImpl.set(UnsafeObjectFieldAccessorImpl.java:81) ~[na:na]
        at java.base/java.lang.reflect.Field.set(Field.java:780) ~[na:na]
        at org.hibernate.property.access.spi.SetterFieldImpl.set(SetterFieldImpl.java:52) ~[hibernate-core-5.4.27.Final.jar:5.4.27.Final]
...
```

I believe that it is a known problem to try to use `@IdClass` and `@GeneratedValue` without the database supporting sequences...

## Simple ID (branch "SimpleId")

### Mapping
```java
@Entity
@Table(name = "test")
public class Test implements Serializable {

    @Id
    @Column(name = "test_id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "uuid")
    @Type(type = "org.hibernate.type.UUIDCharType")
    private UUID uuid;

    @Column(name = "name")
    private String name;

    @Column(name = "test_date")
    @JsonSerialize(using = LocalDateSerializer.class)
    private LocalDate date;

    //...
}
```

### Testing
```shell
curl -s -X POST http://localhost:8080/test/ -d "name=Juliet" | jq
```
```json
{
  "id": 2,
  "uuid": "7c913957-808e-4301-baed-9f6d3b83b07a",
  "name": "Juliet",
  "date": "2021-02-11"
}

```

Look! The ID! :smile:

```shell
curl -s -X GET http://localhost:8080/test/ | jq
```

```json
[
  {
    "id": 1,
    "uuid": "0a3c6c5b-c6e5-45f2-94fd-5d5d09c6b45e",
    "name": "Jonny",
    "date": "2021-02-11"
  },
  {
    "id": 2,
    "uuid": "7c913957-808e-4301-baed-9f6d3b83b07a",
    "name": "Juliet",
    "date": "2021-02-11"
  }
]
```

Conclusion, without Natural ID it works...

